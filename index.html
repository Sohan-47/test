<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-visual">
    <title>ABLE - A Better LaTeX Editor</title>

    <!-- MathLive CDN -->
    <script src="https://unpkg.com/mathlive"></script>

    <!-- PDF Export Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        // Use a persistent function for mode toggling that html can see
        window.toggleMode = function () {
            // Placeholder, overwritten in main script
            console.log("Toggle Mode");
        };
    </script>

    <style>
        :root {
            --grid-color: rgba(77, 166, 255, 0.15);
            --accent: #4da6ff;
            --bg: #1e1e1e;
            --panel: #2d2d2d;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg);
            color: #e0e0e0;
            margin: 0;
            min-height: 100vh;
            width: 100vw;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            cursor: crosshair;
        }

        /* --- BACKGROUND GRID LAYER --- */
        #grid-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            background-image: radial-gradient(var(--grid-color) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        /* --- UI COMPONENTS --- */
        #brand-header,
        #mode-status,
        #help-btn,
        .controls,
        .sidebar,
        .box-handle,
        #arrow-layer {
            user-select: none;
        }

        #brand-header {
            position: fixed;
            top: 20px;
            left: 25px;
            pointer-events: none;
            z-index: 2000;
        }

        #brand-header h1 {
            margin: 0;
            font-size: 2.2rem;
            color: var(--accent);
            font-weight: 800;
            letter-spacing: 2px;
            line-height: 1.1;
        }

        #brand-header p {
            margin: 0;
            font-size: 0.85rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sidebar {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--panel);
            border: 1px solid #444;
            padding: 10px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 3000;
            box-shadow: 0 4px 25px rgba(0, 0, 0, 0.6);
        }

        .side-btn {
            width: 44px;
            height: 44px;
            background: #383838;
            border: 1px solid #444;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .side-btn:hover {
            background: #444;
            border-color: var(--accent);
        }

        .side-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(77, 166, 255, 0.5);
        }

        /* Zoom wrapper - contains all zoomable content */
        #zoom-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            min-height: 100vh;
            transform-origin: top left;
            will-change: transform;
            /* No transition for instant, smooth pan/zoom on mobile */
        }

        /* Optimization - promotes to GPU layer */
        #zoom-wrapper {
            will-change: transform;
            transform: translate3d(0, 0, 0);
            /* Ensure pointer-events pass through wrapper to children if needed, 
               but wrapper usually contains the content so auto is fine. 
               Checking JS, zoom-wrapper wraps canvas-area. */
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            transform-origin: 0 0;
        }

        #canvas-area {
            width: 100%;
            min-height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #arrow-layer {
            width: 100%;
            min-height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 50;
            pointer-events: none;
        }

        #drawing-layer {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
            pointer-events: none;
        }

        #preview-layer {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 6;
            pointer-events: none;
        }

        #drawing-interaction-surface {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 7;
            display: none;
        }

        #drawing-interaction-surface.active {
            display: block;
        }

        .math-box {
            position: absolute;
            background: var(--panel);
            border: 1px solid #444;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            min-width: 50px;
            /* Reduced min-width */
            width: max-content;
            /* Allow growing */
            max-width: none;
            /* UNCAPPED */
            display: flex;
            flex-direction: column;
            z-index: 100;
        }

        .math-box.focused {
            border-color: var(--accent);
            box-shadow: 0 0 20px rgba(77, 166, 255, 0.25);
        }

        .box-handle {
            height: 24px;
            background: #383838;
            border-top-left-radius: 9px;
            border-top-right-radius: 9px;
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .box-handle::after {
            content: "";
            width: 35px;
            height: 3px;
            background: #555;
            border-radius: 2px;
        }

        .close-box-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 24px;
            height: 24px;
            background: #ff5f57;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 22px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 1;
            /* Always visible on touch usually, but keeping hover for desktop */
            transition: opacity 0.2s;
            z-index: 200;
        }

        .math-box:hover .close-box-btn {
            opacity: 1;
        }

        /* Mobile Always Show Close Button */
        @media (max-width: 768px) {
            .close-box-btn {
                opacity: 1;
            }
        }

        math-field {
            font-size: 26px;
            padding: 12px 24px 18px 24px;
            background: transparent;
            border: none;
            outline: none;
            color: white;
            min-width: 60px;
            --caret-color: var(--accent);
        }

        #mode-status {
            position: fixed;
            top: 20px;
            right: 90px;
            background: #1e293b;
            padding: 8px 14px;
            border-radius: 8px;
            font-family: monospace;
            font-weight: bold;
            font-size: 12px;
            color: #64748b;
            border: 1px solid #334155;
            z-index: 2500;
            cursor: pointer;
            /* Clickable */
        }

        #mode-status.active {
            color: var(--accent);
            border-color: var(--accent);
        }

        /* --- DOCUMENT MODE STYLES --- */
        body.document-mode {
            background-color: #1a1a1a;
            /* Outer background darker to make page pop */
        }

        body.document-mode #grid-layer {
            display: none;
        }

        .document-mode #zoom-wrapper {
            /* Center the content */
            display: flex;
            align-items: center;
            justify-content: center;
            /* In document mode, we center the wrapper's content logic differently */
        }

        /* The "Page" look */
        .page-boundary {
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
            background-color: #2d2d2d;
            /* Dark page as requested */
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 12px 20px;
            font-size: 13px;
            color: #999;
            background: #181818;
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 4000;
        }

        .key-hint {
            background: #333;
            padding: 2px 8px;
            border-radius: 5px;
            color: #eee;
            font-family: monospace;
            border: 1px solid #444;
            margin-right: 4px;
        }

        .instructions {
            display: flex;
            gap: 20px;
        }

        #help-btn {
            position: fixed;
            top: 20px;
            right: 30px;
            width: 38px;
            height: 38px;
            background: var(--panel);
            border: 1px solid #444;
            border-radius: 50%;
            color: var(--accent);
            font-weight: bold;
            cursor: pointer;
            z-index: 2500;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 8px 18px;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            margin-left: 5px;
        }

        #toast {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            z-index: 6000;
            display: none;
        }

        /* --- PERFORMANCE OPTIMIZATIONS --- */
        body.is-zooming .page-boundary {
            box-shadow: none !important;
            border-color: #555 !important;
            /* Simplified border instead */
        }

        body.is-zooming .math-box {
            box-shadow: none !important;
            border: 1px solid #4da6ff !important;
            /* Keep visibility */
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 5000;
            align-items: center;
            justify-content: center;
            cursor: default;
        }

        .help-content {
            background: var(--bg);
            width: 95%;
            max-width: 1400px;
            padding: 30px;
            border-radius: 15px;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid #333;
        }

        .help-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 25px;
        }

        .help-section h3 {
            color: var(--accent);
            border-bottom: 1px solid #333;
            padding-bottom: 5px;
            margin-top: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            font-weight: 800;
            letter-spacing: 1px;
        }

        .shortcut-list {
            list-style: none;
            padding: 0;
            font-size: 12px;
        }

        .shortcut-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            border-bottom: 1px solid #252525;
            transition: all 0.2s ease;
            border-radius: 4px;
        }

        .shortcut-list li:hover {
            background: rgba(77, 166, 255, 0.1);
            color: #fff;
            text-shadow: 0 0 10px var(--accent);
        }

        .symbol {
            font-size: 1.15rem;
            color: #fff;
            font-family: serif;
        }

        .cmd {
            font-family: monospace;
            color: #7cb7ff;
            background: #2a2a2a;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
        }

        @media print {
            body {
                background: white !important;
                color: black !important;
            }

            #grid-layer,
            .sidebar,
            #mode-status,
            #help-btn,
            .controls,
            .modal-overlay,
            #toast {
                display: none !important;
            }

            .box-handle,
            .close-box-btn {
                display: none !important;
            }

            .math-box {
                background: transparent !important;
                border: none !important;
                box-shadow: none !important;
            }

            math-field {
                color: black !important;
            }
        }

        /* === MOBILE RESPONSIVE STYLES === */
        /* === MOBILE RESPONSIVE STYLES - COLLAPSIBLE DRAWER === */

        /* Mobile menu toggle button - only visible on mobile */
        #mobile-menu-btn {
            display: none;
            position: fixed;
            top: 10px;
            left: 10px;
            width: 44px;
            height: 44px;
            background: var(--accent);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 22px;
            cursor: pointer;
            z-index: 4000;
            box-shadow: 0 4px 15px rgba(77, 166, 255, 0.5);
            align-items: center;
            justify-content: center;
        }

        /* Mobile zoom controls */
        #mobile-zoom-controls {
            display: none;
            position: fixed;
            bottom: 80px;
            right: 10px;
            flex-direction: column;
            gap: 8px;
            z-index: 3500;
        }

        #mobile-zoom-controls button {
            width: 44px;
            height: 44px;
            background: var(--panel);
            border: 1px solid #444;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        #mobile-zoom-controls button:active {
            background: var(--accent);
        }

        /* Mobile drawer overlay */
        #mobile-drawer-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 3999;
        }

        /* Mobile drawer */
        #mobile-drawer {
            display: none;
            position: fixed;
            top: 0;
            left: -280px;
            width: 260px;
            height: 100%;
            background: var(--panel);
            border-right: 1px solid #444;
            z-index: 4001;
            padding: 20px;
            box-sizing: border-box;
            transition: left 0.3s ease;
            overflow-y: auto;
        }

        #mobile-drawer.open {
            left: 0;
        }

        #mobile-drawer h3 {
            color: var(--accent);
            font-size: 14px;
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #444;
            padding-bottom: 8px;
        }

        #mobile-drawer .drawer-section {
            margin-bottom: 20px;
        }

        #mobile-drawer .drawer-tools {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        #mobile-drawer .drawer-btn {
            width: 100%;
            aspect-ratio: 1;
            background: #383838;
            border: 1px solid #444;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #mobile-drawer .drawer-btn.active {
            background: var(--accent);
            border-color: var(--accent);
        }

        #mobile-drawer .drawer-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #mobile-drawer .drawer-actions .btn {
            width: 100%;
            margin: 0;
        }

        /* Mobile text input helper - collapsible floating widget */
        #mobile-input-container {
            display: none;
            position: fixed;
            bottom: 10px;
            right: 10px;
            z-index: 3500;
        }

        #mobile-input-toggle {
            width: 44px;
            height: 44px;
            background: var(--accent);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(77, 166, 255, 0.4);
        }

        #mobile-input-panel {
            display: none;
            position: absolute;
            bottom: 54px;
            right: 0;
            width: 280px;
            background: var(--panel);
            border: 1px solid #444;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        #mobile-input-panel.open {
            display: block;
        }

        #mobile-input-panel input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            background: #383838;
            border: 1px solid #444;
            border-radius: 8px;
            color: white;
            box-sizing: border-box;
        }

        #mobile-input-panel input:focus {
            outline: none;
            border-color: var(--accent);
        }

        #mobile-input-hint {
            font-size: 11px;
            color: #888;
            margin-top: 8px;
            text-align: center;
        }

        @media (max-width: 768px) {
            body {
                cursor: default;
            }

            /* Prevent viewport shift when keyboard appears */
            html,
            body {
                overscroll-behavior: none;
                -webkit-overflow-scrolling: touch;
            }

            /* Show brand header on mobile (Top Left) */
            #brand-header {
                display: block;
                top: 10px;
                left: 10px;
            }

            #brand-header h1 {
                font-size: 1.2rem;
            }

            #brand-header p {
                font-size: 0.6rem;
            }

            /* Hide original sidebar on mobile */
            .sidebar {
                display: none !important;
            }

            /* Hide original controls on mobile */
            .controls {
                display: none !important;
            }

            /* Show mobile menu button (Hamburger) - Positioned a bit above middle */
            #mobile-menu-btn {
                display: flex;
                top: 40%;
                /* A bit above middle */
                left: 10px;
            }

            /* Show mobile drawer (hidden by default, slides in) */
            #mobile-drawer {
                display: block;
            }

            #mobile-drawer-overlay.open {
                display: block;
            }

            /* Show mobile input container and zoom controls */
            #mobile-input-container {
                display: block;
            }

            #mobile-zoom-controls {
                display: none;
                /* Hide container if still used, but we moved button out */
            }

            /* Reposition Help Button - Top Right */
            #help-btn {
                position: fixed;
                top: 10px;
                right: 10px;
                left: auto !important;
                /* Force override */
                width: 32px;
                height: 32px;
                font-size: 14px;
                z-index: 10000 !important;
                pointer-events: auto !important;
            }

            /* Reposition Mode Status - Below Help Button (Right Aligned) */
            #mode-status {
                position: fixed;
                top: 50px !important;
                /* Below help button */
                right: 10px !important;
                /* Aligned right */
                left: auto !important;
                /* Force override */
                font-size: 10px;
                padding: 5px 10px;
                cursor: pointer;
                background: #383838;
                color: white;
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
                z-index: 10000 !important;
                pointer-events: auto !important;
            }

            #mode-status:active {
                background: var(--accent);
            }



            /* Hide drag handle on mobile for cleaner look */
            /* Handle visible on mobile now */
            .box-handle {
                /* display: none; */
            }

            /* Close button visible on mobile now */
            .close-box-btn {
                /* display: none; */
            }

            /* Math boxes bigger on mobile */
            /* Math boxes bigger on mobile */
            .math-box {
                min-width: 250px;
                /* Max width removed here too to prevent capping */
                min-height: 60px;
            }

            math-field {
                font-size: 24px;
                padding: 14px 18px 18px 18px;
                min-height: 50px;
            }

            /* Custom styling for MathLive virtual keyboard */
            .ML__keyboard {
                --keyboard-background: #1e1e1e !important;
                --keycap-background: #2d2d2d !important;
                --keycap-text: #e0e0e0 !important;
                --keycap-background-active: #4da6ff !important;
                --keycap-height: 52px !important;
                /* Subtle increase (was 60px) */
                z-index: 5000 !important;
            }

            .ML__keyboard .MLK__keycap {
                background: #2d2d2d !important;
                color: #e0e0e0 !important;
                border: 1px solid #444 !important;
                border-radius: 6px !important;
                font-size: 20px !important;
                /* Subtle increase (was 24px) */
                height: 52px !important;
                /* Enforced height */
            }

            .ML__keyboard .MLK__keycap:active,
            .ML__keyboard .MLK__keycap.is-active {
                background: var(--accent) !important;
            }

            /* Help modal mobile */
            .help-content {
                padding: 20px;
                max-height: 85vh;
            }

            .help-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            /* Toast positioning for mobile */
            #toast {
                bottom: 80px;
            }

            /* --- NEW MOBILE UI --- */
            /* FABs Container */
            .mobile-fab-container {
                position: fixed;
                top: 40%;
                left: 10px;
                display: flex;
                flex-direction: column;
                gap: 15px;
                z-index: 4000;
            }

            .mobile-fab {
                width: 48px;
                height: 48px;
                border-radius: 50%;
                background: var(--panel);
                border: 1px solid #444;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
                transition: transform 0.2s, background 0.2s;
                position: relative;
            }

            .mobile-fab:active,
            .mobile-fab.active {
                transform: scale(0.95);
                background: #444;
                border-color: var(--accent);
                color: var(--accent);
            }

            /* Tools Panel - Rectangular Slide-out (Grid Layout) */
            .mobile-tools-panel {
                position: absolute;
                left: 60px;
                top: 0;
                background: var(--panel);
                border: 1px solid #444;
                border-radius: 12px;
                padding: 8px;
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                /* 2 Columns */
                gap: 8px;
                opacity: 0;
                visibility: hidden;
                transform: translateX(-10px);
                transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
                width: max-content;
            }

            .mobile-tools-panel.open {
                opacity: 1;
                visibility: visible;
                transform: translateX(0);
            }

            .mobile-tool-btn {
                width: 40px;
                height: 40px;
                border-radius: 8px;
                background: #383838;
                border: 1px solid #444;
                color: #ddd;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .mobile-tool-btn.active {
                background: var(--accent);
                color: white;
                border-color: var(--accent);
            }

            /* File Palette - Fan/Slide out */
            .mobile-file-palette {
                position: absolute;
                left: 60px;
                top: 0;
                display: flex;
                gap: 12px;
                pointer-events: none;
                /* Let clicks pass when closed */
            }

            .palette-btn {
                width: 44px;
                height: 44px;
                border-radius: 50%;
                background: var(--panel);
                border: 1px solid #444;
                color: white;
                display: flex;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                cursor: pointer;
                opacity: 0;
                transform: translateX(-20px) scale(0.8);
                transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                pointer-events: auto;
            }

            .mobile-fab-container.file-open .palette-btn {
                opacity: 1;
                transform: translateX(0) scale(1);
            }

            /* Staggered animation handled in JS or via nth-child delay */
            .palette-btn:nth-child(1) {
                transition-delay: 0.05s;
            }

            .palette-btn:nth-child(2) {
                transition-delay: 0.1s;
            }

            .palette-btn:nth-child(3) {
                transition-delay: 0.15s;
            }

            /* Label hints for palette */
            .palette-btn::after {
                content: attr(data-label);
                position: absolute;
                top: -25px;
                background: #222;
                color: #aaa;
                font-size: 10px;
                padding: 2px 6px;
                border-radius: 4px;
                white-space: nowrap;
                opacity: 0;
                transition: opacity 0.2s;
                pointer-events: none;
            }

            .palette-btn:active::after {
                opacity: 1;
            }
        }
    </style>
</head>

<body class="grid-bg">

    <div id="grid-layer"></div>

    <div id="brand-header">
        <h1>ABLE</h1>
        <p>A better LaTeX Editor</p>
    </div>

    <div id="mode-status" class="active">MODE: MATH</div>
    <button id="help-btn" title="Help (F1)">?</button>
    <div id="toast">Message</div>

    <div class="sidebar">
        <button id="tool-pointer" class="side-btn active" title="Pointer (Select Boxes)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z" />
                <path d="M13 13l6 6" />
            </svg>
        </button>
        <button id="tool-pen" class="side-btn" title="Pen (Scribble)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M12 19l7-7 3 3-7 7-3-3z" />
                <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" />
                <path d="M2 2l5 5" />
                <path d="M11 22l2-2" />
            </svg>
        </button>
        <button id="tool-line" class="side-btn" title="Straight Line">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="5" y1="19" x2="19" y2="5" />
            </svg>
        </button>
        <button id="tool-circle" class="side-btn" title="Circle / Ellipse">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="9" />
            </svg>
        </button>
        <button id="tool-curve" class="side-btn" title="Curved Line (MS Paint Style)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12c0-5 9-5 9 0s9 5 9 0" />
            </svg>
        </button>
        <button id="tool-eraser" class="side-btn" title="Eraser (Rub drawings)">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M20 20H7L3 16C2 15 2 13 3 12L13 2L22 11L20 20Z" />
                <path d="M17 17L7 7" />
            </svg>
        </button>
        <button id="tool-arrow" class="side-btn" title="Draw Arrow">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="5" y1="19" x2="19" y2="5" />
                <polyline points="10 5 19 5 19 14" />
            </svg>
        </button>
        <button id="tool-grid" class="side-btn active" title="Toggle Grid Visibility">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />
                <line x1="3" y1="9" x2="21" y2="9" />
                <line x1="3" y1="15" x2="21" y2="15" />
                <line x1="9" y1="3" x2="9" y2="21" />
                <line x1="15" y1="3" x2="15" y2="21" />
            </svg>
        </button>
    </div>

    <!-- Zoomable content wrapper - only this zooms, UI stays fixed -->
    <div id="zoom-wrapper">
        <canvas id="drawing-layer"></canvas>
        <canvas id="preview-layer"></canvas>
        <div id="drawing-interaction-surface"></div>

        <svg id="arrow-layer">
            <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                    <polygon points="0 0, 10 3.5, 0 7" fill="#4da6ff" />
                </marker>
            </defs>
        </svg>

        <div id="canvas-area"></div>
    </div>

    <div class="controls">
        <div class="instructions">
            <span><span class="key-hint">Dbl Click</span> New Box</span>
            <span><span class="key-hint">Shift + Drag</span> Arrow</span>
            <span><span class="key-hint">F1</span> Help Menu</span>
        </div>
        <div>
            <button id="clear-btn" class="btn" style="background:#dc2626">Clear Editor</button>
            <button id="undo-btn" class="btn" style="background:#444">Undo Action</button>
            <button id="export-able-btn" class="btn" style="background:#059669">Export .able</button>
            <button id="import-able-btn" class="btn" style="background:#7c3aed">Import .able</button>
            <button id="export-btn" class="btn">Export PDF</button>
        </div>
    </div>

    <input type="file" id="file-input" accept=".able" style="display: none;">

    <!-- Mobile FABs -->
    <div class="mobile-fab-container">
        <!-- Tools FAB -->
        <div style="position:relative;">
            <div id="mobile-tools-btn" class="mobile-fab" title="Drawing Tools">
                <!-- Pen Icon -->
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 19l7-7 3 3-7 7-3-3z"></path>
                    <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path>
                </svg>
            </div>
            <!-- Slide-out Tools Panel -->
            <div id="mobile-tools-panel" class="mobile-tools-panel">
                <div class="mobile-tool-btn active" data-tool="pointer"><svg width="20" height="20" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z" />
                    </svg></div>
                <div class="mobile-tool-btn" data-tool="pen"><svg width="20" height="20" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2">
                        <path d="M12 19l7-7 3 3-7 7-3-3z" />
                        <path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z" />
                    </svg></div>
                <div class="mobile-tool-btn" data-tool="eraser"><svg width="20" height="20" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M20 20H7L3 16C2 15 2 13 3 12L13 2L22 11L20 20Z" />
                    </svg></div>
                <div class="mobile-tool-btn" data-tool="line"><svg width="20" height="20" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="5" y1="19" x2="19" y2="5" />
                    </svg></div>
                <div class="mobile-tool-btn" data-tool="circle"><svg width="20" height="20" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="9" />
                    </svg></div>
                <div class="mobile-tool-btn" data-tool="curve" title="Curve"><svg width="20" height="20"
                        viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12c0-5 9-5 9 0s9 5 9 0" />
                    </svg></div>
                <div class="mobile-tool-btn" data-tool="arrow" title="Arrow" style="grid-column: span 2; width: auto;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="5" y1="19" x2="19" y2="5" />
                        <polyline points="10 5 19 5 19 14" />
                    </svg></div>
            </div>
        </div>

        <!-- File FAB -->
        <div style="position:relative;">
            <div id="mobile-file-btn" class="mobile-fab" title="File Actions">
                <!-- Folder Icon -->
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                </svg>
            </div>
            <!-- Slide-out File Palette -->
            <div id="mobile-file-palette" class="mobile-file-palette">
                <!-- Export .able (Down Arrow) -->
                <div class="palette-btn" id="pal-export-able" data-label="Export .able"
                    style="color:#059669; border-color:#059669;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                        <text x="16" y="10"
                            style="font-size:6px; fill:currentColor; stroke:none; font-weight:bold;">ABLE</text>
                    </svg>
                </div>
                <!-- Import .able (Up Arrow) -->
                <div class="palette-btn" id="pal-import-able" data-label="Import .able"
                    style="color:#7c3aed; border-color:#7c3aed;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                        <text x="16" y="10"
                            style="font-size:6px; fill:currentColor; stroke:none; font-weight:bold;">ABLE</text>
                    </svg>
                </div>
                <!-- Clear All (Red Brush/Trash) -->
                <div class="palette-btn" id="pal-clear" data-label="Clear All"
                    style="color:#dc2626; border-color:#dc2626;">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18"></path>
                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                    </svg>
                </div>
            </div>
        </div>
    </div>

    <!-- Standalone Undo Button -->
    <button id="mobile-undo-btn-standalone" title="Undo"
        style="position:fixed; top:128px; right:10px; width:34px; height:34px; background:#383838; color:white; border:1px solid #444; border-radius:8px; font-size:16px; z-index:3500; cursor:pointer; display:flex; align-items:center; justify-content:center;">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M9 14L4 9l5-5" />
            <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11" />
        </svg>
    </button>

    <!-- Mobile Zoom Controls -->
    <!-- +/- Buttons removed by request -->
    <button id="zoom-reset-btn" title="Reset Zoom"
        style="position:fixed; top:88px; right:10px; width:34px; height:34px; background:#383838; color:white; border:1px solid #444; border-radius:8px; font-size:18px; z-index:3500; cursor:pointer;">‚ü≤</button>

    <!-- Using MathLive's custom minimal QWERTY keyboard instead of native keyboard proxy -->

    <div id="help-modal" class="modal-overlay">
        <div class="help-content">
            <h2 style="text-align:center; color:#4da6ff; margin-bottom:30px; font-weight:800; letter-spacing:1px;">ABLE
                COMPREHENSIVE SHORTCUT DIRECTORY</h2>
            <div class="help-grid">
                <!-- Section 1 -->
                <div class="help-section">
                    <h3>Canvas and storage</h3>
                    <ul class="shortcut-list">
                        <li><span>Create Box</span> <span class="cmd">Double Click</span></li>
                        <li><span>Draw Arrow</span> <span class="cmd">Shift + Drag</span></li>
                        <li><span>Export File</span> <span class="cmd">.able button</span></li>
                        <li><span>Import File</span> <span class="cmd">.able button</span></li>
                        <li><span>Mode Toggle</span> <span class="key-hint">Shift + Tab</span></li>
                        <li><span>Undo Arrow</span> <span class="cmd">Ctrl + Z</span></li>
                    </ul>
                </div>
                <!-- Section 2 -->
                <div class="help-section">
                    <h3>Calculus</h3>
                    <ul class="shortcut-list">
                        <li><span class="symbol">‚à´</span> <span class="cmd">int</span></li>
                        <li><span class="symbol">‚à´_a^b</span> <span class="cmd">dint</span></li>
                        <li><span class="symbol">‚à¨ / ‚à≠</span> <span class="cmd">iint / iiint</span></li>
                        <li><span class="symbol">‚àÆ / ‚àØ / ‚à∞</span> <span class="cmd">oint / oiint / oiiint</span></li>
                        <li><span class="symbol">‚àá / ‚àÇ</span> <span class="cmd">grad / del</span></li>
                        <li><span class="symbol">‚àë / ‚àè</span> <span class="cmd">sum / prod</span></li>
                        <li><span class="symbol">‚àû</span> <span class="cmd">ify</span></li>
                    </ul>
                </div>
                <!-- Section 3 -->
                <div class="help-section">
                    <h3>Vectors</h3>
                    <ul class="shortcut-list">
                        <li><span class="symbol">v‚Éó</span> <span class="cmd">vec</span></li>
                        <li><span class="symbol">√ª</span> <span class="cmd">hat</span></li>
                        <li><span class="symbol">‚ãÖ</span> <span class="cmd">ast</span></li>
                        <li><span class="symbol">√ó</span> <span class="cmd">times</span></li>
                        <li><span class="symbol">‚Äñv‚Äñ</span> <span class="cmd">||</span></li>
                        <li><span class="symbol">vÃÖ</span> <span class="cmd">bar</span></li>
                    </ul>
                </div>
                <!-- Section 4 -->
                <div class="help-section">
                    <h3>Linear algebra</h3>
                    <ul class="shortcut-list">
                        <li><span class="symbol">[M√óN] Matrix</span> <span class="cmd">mnmat</span></li>
                        <li><span class="symbol">|M√óN| Det</span> <span class="cmd">mndet</span></li>
                        <li><span class="symbol">det(A)</span> <span class="cmd">det</span></li>
                        <li><span class="symbol">A·µÄ Transpose</span> <span class="cmd">^T</span></li>
                        <li><span class="symbol">‚äï / ‚äó</span> <span class="cmd">bop / bot</span></li>
                    </ul>
                </div>
                <!-- Section 5 -->
                <div class="help-section">
                    <h3>Set theory and logic</h3>
                    <ul class="shortcut-list">
                        <li><span class="symbol">‚àà / ‚àâ</span> <span class="cmd">in / notin</span></li>
                        <li><span class="symbol">‚à¥ / ‚àµ</span> <span class="cmd">tf / bc</span></li>
                        <li><span class="symbol">‚àÄ / ‚àÉ</span> <span class="cmd">AA / EE</span></li>
                        <li><span class="symbol">‚àß / ‚à®</span> <span class="cmd">and / or</span></li>
                        <li><span class="symbol">‚Ñù / ‚Ñ§ / ‚Ñï / ‚ÑÇ</span> <span class="cmd">RR / ZZ / NN / CC</span></li>
                    </ul>
                </div>
                <!-- Section 6 -->
                <div class="help-section">
                    <h3>Quantum physics</h3>
                    <ul class="shortcut-list">
                        <li><span class="symbol">‚ü®œÜ|</span> <span class="cmd">bra</span></li>
                        <li><span class="symbol">|œà‚ü©</span> <span class="cmd">ket</span></li>
                        <li><span class="symbol">‚ü®œÜ|œà‚ü©</span> <span class="cmd">braket</span></li>
                        <li><span class="symbol">ƒ§ / ‚Ä†</span> <span class="cmd">hatH / dag</span></li>
                        <li><span class="symbol">‚Ñè / ‚Ñì</span> <span class="cmd">hbar / ell</span></li>
                    </ul>
                </div>
                <!-- Section 7 -->
                <div class="help-section">
                    <h3>Numpad structures</h3>
                    <ul class="shortcut-list">
                        <li><span class="symbol">‚à´·µÉ·µá</span> <span class="key-hint">Num 7</span></li>
                        <li><span class="symbol">‚àë‚Åø</span> <span class="key-hint">Num 8</span></li>
                        <li><span class="symbol">‚àöx</span> <span class="key-hint">Num 9</span></li>
                        <li><span class="symbol">lim</span> <span class="key-hint">Num 4</span></li>
                        <li><span class="symbol">Matrix [Cycle]</span> <span class="key-hint">Num 5</span></li>
                    </ul>
                </div>
                <!-- Section 8 -->
                <div class="help-section">
                    <h3>Styling, Decors and accents</h3>
                    <ul class="shortcut-list">
                        <li><span class="symbol">[Box]</span> <span class="cmd">box</span></li>
                        <li><span class="symbol">Strike</span> <span class="cmd">can</span></li>
                        <li><span class="symbol">Over/Under</span> <span class="cmd">obra / ubra</span></li>
                        <li><span class="symbol">ùíûùí∂ùìÅùìÅùíæ</span> <span class="cmd">mcal</span></li>
                        <li><span class="symbol">Greek Letters</span> <span class="cmd">alpha, beta...</span></li>
                        <li><span class="symbol">ùêÅùê®ùê•ùêù</span> <span class="cmd">mbf</span></li>
                    </ul>
                </div>
                <!-- Section 9 -->
                <div class="help-section">
                    <h3>Geometry and arrows</h3>
                    <ul class="shortcut-list">
                        <li><span class="symbol">‚à†</span> <span class="cmd">ang</span></li>
                        <li><span class="symbol">‚ä• / ‚à•</span> <span class="cmd">perp / para</span></li>
                        <li><span class="symbol">‚áí / ‚áî</span> <span class="cmd">impl / iff</span></li>
                        <li><span class="symbol">‚Üë / ‚Üì / ‚Üî</span> <span class="cmd">up / dn / lr</span></li>
                        <li><span class="symbol">‚Ü¶</span> <span class="cmd">map</span></li>
                    </ul>
                </div>
            </div>
            <button class="close-help" onclick="toggleHelp()"
                style="width:100%; margin-top:30px; padding:12px; background:var(--accent); color:white; border:none; border-radius:8px; cursor:pointer; font-weight:bold;">Close</button>
        </div>
    </div>

    <script>
        // --- GLOBAL SELECTORS ---
        const canvasArea = document.getElementById('canvas-area');
        const arrowLayer = document.getElementById('arrow-layer');
        const drawingLayer = document.getElementById('drawing-layer');
        const previewLayer = document.getElementById('preview-layer');
        const drawSurface = document.getElementById('drawing-interaction-surface');
        const dCtx = drawingLayer.getContext('2d');
        const pCtx = previewLayer.getContext('2d');
        const statusEl = document.getElementById('mode-status');
        const helpModal = document.getElementById('help-modal');
        const toastEl = document.getElementById('toast');
        const fileInput = document.getElementById('file-input');

        // App State
        let lastMatrixTap = 0;
        let matrixSize = 0;
        let isMathMode = true;
        let historyStack = [];
        const MAX_HISTORY_SIZE = 30; // Limit history to prevent memory leaks
        let saveTimeout = null;
        const AUTOSAVE_DELAY = 2000; // Debounce autosave by 2 seconds

        // Input States
        let isDrawing = false;
        let isDrawingArrow = false;
        let activeLine = null;
        let startX, startY;
        let currentTool = 'pointer';
        let curveStep = 0;
        let curveStartX, curveStartY, curveEndX, curveEndY;

        /* --- VERBOSE SHORTCUT LOGIC - FULL LIST (MOVED TO TOP) --- */
        const savedShortcuts = {
            'alpha': '\\alpha', 'beta': '\\beta', 'gamma': '\\gamma', 'delta': '\\delta', 'epsilon': '\\epsilon',
            'vepsilon': '\\varepsilon', 'zeta': '\\zeta', 'eta': '\\eta', 'theta': '\\theta', 'vtheta': '\\vartheta',
            'iota': '\\iota', 'kappa': '\\kappa', 'lambda': '\\lambda', 'mu': '\\mu', 'nu': '\\nu', 'xi': '\\xi',
            'pi': '\\pi', 'rho': '\\rho', 'vrho': '\\varrho', 'sigma': '\\sigma', 'tau': '\\tau', 'upsilon': '\\upsilon',
            'phi': '\\phi', 'vphi': '\\varphi', 'chi': '\\chi', 'psi': '\\psi', 'omega': '\\omega',
            'Gamma': '\\Gamma', 'Delta': '\\Delta', 'Theta': '\\Theta', 'Lambda': '\\Lambda', 'Xi': '\\Xi',
            'Pi': '\\Pi', 'Sigma': '\\Sigma', 'Upsilon': '\\Upsilon', 'Phi': '\\Phi', 'Psi': '\\Psi', 'Omega': '\\Omega',
            'ify': '\\infty', 'pm': '\\pm', 'grad': '\\nabla', 'del': '\\partial', 'xx': '\\times', 'ast': '\\cdot', 'times': '\\times',
            'tf': '\\therefore', 'bc': '\\because', 'and': '\\land', 'or': '\\lor', 'not': '\\neg', 'eqv': '\\equiv',
            'sim': '\\sim', 'approx': '\\approx', 'prop': '\\propto', 'LL': '\\ll', 'GG': '\\gg', 'AA': '\\forall', 'EE': '\\exists',
            'bra': '\\bra{#@}', 'ket': '\\ket{#@}', 'braket': '\\braket{#@ | #@}', 'hatH': '\\hat{H}', 'dag': '\\dagger', 'hbar': '\\hbar', 'ell': '\\ell',
            'ale': '\\aleph', 'bet': '\\beth', 'dal': '\\daleth', 'mscr': '\\mathscr{#@}', 'in': '\\in', 'notin': '\\notin', 'uu': '\\cup', 'nn': '\\cap',
            'sub': '\\subset', 'sup': '\\supset', 'sube': '\\subseteq', 'supe': '\\supseteq', 'eset': '\\emptyset',
            'RR': '\\mathbb{R}', 'ZZ': '\\mathbb{Z}', 'NN': '\\mathbb{N}', 'CC': '\\mathbb{C}', 'QQ': '\\mathbb{Q}',
            'int': '\\int', 'dint': '\\int_{#@}^{#@}', 'iint': '\\iint', 'iiint': '\\iiint', 'oint': '\\oint', 'oiint': '\\oiint', 'oiiint': '\\oiiint',
            'prod': '\\prod_{#@}^{#@}', 'sum': '\\sum_{#@}^{#@}', 'bcap': '\\bigcap', 'bcup': '\\bigcup', 'bop': '\\bigoplus', 'bot': '\\bigotimes',
            'asin': '\\arcsin', 'acos': '\\arccos', 'atan': '\\arctan', 'sinh': '\\sinh', 'cosh': '\\cosh', 'log': '\\log_{#@}{#@}', 'ln': '\\ln{#@}',
            'can': '\\cancel{#@}', 'box': '\\boxed{#@}', 'obra': '\\overbrace{#@}^{#@}', 'ubra': '\\underbrace{#@}_{#@}', 'ang': '\\angle', 'perp': '\\perp',
            'para': '\\parallel', 'tri': '\\triangle', 'sq': '\\square', 'deg': '^\\circ', '||': '\\| #@ \\|', 'bar': '\\bar{#@}', 'vec': '\\vec{#@}',
            'hat': '\\hat{#@}', 'dot': '\\dot{#@}', 'ddot': '\\ddot{#@}', 'dddot': '\\dddot{#@}', 'tilde': '\\tilde{#@}', '^T': '^{T}',
            'impl': '\\implies', 'iff': '\\iff', 'ib': '\\impliedby', 'up': '\\uparrow', 'dn': '\\downarrow', 'lr': '\\leftrightarrow', 'map': '\\mapsto',
            'har': '\\rightleftharpoons', 'mcal': '\\mathcal{#@}', 'mfr': '\\mathfrak{#@}', 'mtt': '\\mathtt{#@}', 'mbf': '\\mathbf{#@}', 'mit': '\\mathit{#@}'
        };

        // Improved mobile detection: Touch OR Small Screen
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0 || window.innerWidth <= 1024;

        // Sneaky Fix: Simulate tap on tabs (Robust V2)
        window.sneakySwitchLayer = (label) => {
            console.log("Sneaky switching to:", label);

            // Helper to trigger full click sequence
            const triggerClick = (el) => {
                console.log("Clicking element:", el);
                const opts = { bubbles: true, cancelable: true, view: window };
                el.dispatchEvent(new PointerEvent('pointerdown', opts));
                el.dispatchEvent(new MouseEvent('mousedown', opts));
                el.dispatchEvent(new PointerEvent('pointerup', opts));
                el.dispatchEvent(new MouseEvent('mouseup', opts));
                el.click();
            };

            const findAndClick = (root) => {
                // Expanded selectors for various MathLive versions
                const tabs = root.querySelectorAll('.MLK__layer-tab, .ML__layer-switcher > div, [data-layer], button');
                for (let tab of tabs) {
                    // Check Visible Text or Title or Data Attribute
                    const text = tab.innerText || tab.textContent || "";
                    // Loose matching
                    if (text.trim() === label || tab.getAttribute('data-layer') === label || tab.getAttribute('title') === label || text.includes(label)) {
                        tab.style.backgroundColor = '#ecf0f1'; // Feedback
                        setTimeout(() => tab.style.backgroundColor = '', 150);
                        triggerClick(tab);
                        return true;
                    }
                }
                return false;
            };

            // 1. Try Light DOM
            if (findAndClick(document.body)) return;

            // 2. Try Shadow DOM (math-virtual-keyboard)
            const keyboardEl = document.querySelector('math-virtual-keyboard');
            if (keyboardEl && keyboardEl.shadowRoot) {
                if (findAndClick(keyboardEl.shadowRoot)) return;
            }

            // 3. Last Resort: Global API (Switch by ID if label fails)
            if (window.mathVirtualKeyboard && window.mathVirtualKeyboard.executeCommand) {
                const layerId = (label === 'Shift' || label === '‚áß') ? 'mobile-shift' : (label === '?123' ? 'mobile-symbols' : 'mobile-default');
                window.mathVirtualKeyboard.executeCommand('switchKeyboardLayer', layerId);
            }
        };

        // Continuous Backspace Handlers
        window.backspaceTimer = null;
        window.startBackspace = (e) => {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            // Execute once immediately
            if (window.mathVirtualKeyboard && window.mathVirtualKeyboard.executeCommand) {
                window.mathVirtualKeyboard.executeCommand('deleteBackward');
            }
            // Start repeating after delay
            window.stopBackspace(); // Clear any existing
            window.backspaceTimer = setTimeout(() => {
                window.backspaceInterval = setInterval(() => {
                    if (window.mathVirtualKeyboard && window.mathVirtualKeyboard.executeCommand) {
                        window.mathVirtualKeyboard.executeCommand('deleteBackward');
                    }
                }, 100); // Repeat every 100ms
            }, 500); // Wait 500ms before repeating
        };

        window.stopBackspace = () => {
            if (window.backspaceTimer) clearTimeout(window.backspaceTimer);
            if (window.backspaceInterval) clearInterval(window.backspaceInterval);
        };

        /* === AUTHENTIC GBOARD REPLICA LAYOUT === */
        if (isMobile && window.mathVirtualKeyboard) {
            console.log("Mobile Gboard Layout Active");
            window.mathVirtualKeyboard.layouts = [
                {
                    label: 'ABC',
                    id: 'mobile-default', // Name needed for switching
                    tooltip: 'Letters',
                    rows: [
                        ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
                        [{ latex: '\\sqrt{#0}' }, { latex: '\\frac{#0}{#1}' }, { class: 'action', label: '^', command: ['insert', '^{#?}'] }, { class: 'action', label: '_', command: ['insert', '_{#?}'] }, { class: 'action', label: '‚Üê', command: 'moveToPreviousChar' },
                        { class: 'action', label: '‚Üí', command: 'moveToNextChar' }, { latex: '-' }, { latex: '+' }, { latex: '=' }, { latex: '\\cancel{#@}' },],
                        ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
                        ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'],
                        [
                            // HTML Label Hack: Inline event handler to bypass command system
                            { class: 'action', label: '<span style="display:block; width:100%; height:100%" onpointerdown="event.preventDefault(); event.stopPropagation(); window.sneakySwitchLayer(\'‚áß\');">‚áß</span>', command: 'ignore' },
                            'z', 'x', 'c', 'v', 'b', 'n', 'm',
                            { class: 'action', label: '<span style="display:block; width:100%; height:100%" onpointerdown="window.startBackspace(event)" onpointerup="window.stopBackspace()" onpointerleave="window.stopBackspace()">‚å´</span>', width: 1.5, command: 'ignore' }
                        ],
                        [
                            { class: 'action', label: '<span style="display:block; width:100%; height:100%" onpointerdown="event.preventDefault(); event.stopPropagation(); window.sneakySwitchLayer(\'?123\');">?123</span>', width: 1.5, command: 'ignore' },
                            { latex: ',' },
                            // Removed emoji key to fit spacebar
                            { class: 'action', label: ' ', latex: '\\,', width: 5 },
                            { latex: '.' },
                            { class: 'action', label: '‚Üµ', latex: '\\\\', width: 1.5, style: 'background: #4da6ff; color: white; border-color: #4da6ff;' }
                        ]
                    ]
                },
                {
                    label: '‚áß',
                    id: 'mobile-shift', // Shifted layer
                    tooltip: 'Letters (Caps)',
                    rows: [
                        ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                        ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                        [
                            { class: 'action', label: '‚áß', command: ['switchKeyboardLayer', 'mobile-default'], style: 'background: #4da6ff; color: white;' }, // Toggle back
                            'Z', 'X', 'C', 'V', 'B', 'N', 'M',
                            { class: 'action', label: '<span style="display:block; width:100%; height:100%" onpointerdown="window.startBackspace(event)" onpointerup="window.stopBackspace()" onpointerleave="window.stopBackspace()">‚å´</span>', width: 1.5, command: 'ignore' }
                        ],
                        [
                            { class: 'action', label: '?123', width: 1.5, command: ['switchKeyboardLayer', 'mobile-symbols'] },
                            { latex: ',' },
                            { class: 'action', label: ' ', latex: '\\,', width: 5 },
                            { latex: '.' },
                            { class: 'action', label: '‚Üµ', latex: '\\\\', width: 1.5, style: 'background: #4da6ff; color: white; border-color: #4da6ff;' }
                        ]
                    ]
                },
                {
                    label: '?123',
                    id: 'mobile-symbols', // Name needed for switching
                    tooltip: 'Numbers & Symbols',
                    rows: [
                        ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'],
                        [
                            { latex: '@' }, { latex: '\\#' }, { latex: '‚Çπ' }, { latex: '_' }, { latex: '\\&' },
                            { latex: '-' }, { latex: '+' }, { latex: '(' }, { latex: ')' }, { latex: '/' }
                        ],
                        [
                            { class: 'action', label: '=\\<', width: 1.5, command: ['switchKeyboardLayer', 'mobile-symbols2'] },
                            { latex: '*' }, { latex: '"' }, { latex: "'" }, { latex: ':' }, { latex: ';' }, { latex: '!' }, { latex: '?' },
                            { class: 'action', label: '<span style="display:block; width:100%; height:100%" onpointerdown="window.startBackspace(event)" onpointerup="window.stopBackspace()" onpointerleave="window.stopBackspace()">‚å´</span>', width: 1.5, command: 'ignore' }
                        ],
                        [
                            { class: 'action', label: 'ABC', width: 1.5, command: ['switchKeyboardLayer', 'mobile-default'] },
                            { class: 'action', label: '‚Üê', command: 'moveToPreviousChar' },
                            { class: 'action', label: '‚Üí', command: 'moveToNextChar' },
                            { class: 'action', label: ' ', latex: '\\,', width: 2 },
                            { latex: '.' },
                            { class: 'action', label: '‚Üµ', latex: '\\\\', width: 1.5, style: 'background: #4da6ff; color: white; border-color: #4da6ff;' }
                        ]
                    ]
                },
                {
                    label: '=\\<',
                    id: 'mobile-symbols2', // Name needed for switching
                    tooltip: 'Advanced Symbols',
                    rows: [
                        [
                            { latex: '\\sim' }, { latex: '`' }, { latex: '|' }, { latex: '\\cdot' }, { latex: '\\sqrt{#0}' },
                            { latex: '\\pi' }, { latex: '\\div' }, { latex: '\\times' }, { latex: '\\S' }, { latex: '\\Delta' }
                        ],
                        [
                            { latex: '‚Ç¨' }, { latex: '¬•' }, { latex: '\\$' }, { latex: '¬¢' }, { class: 'action', label: '^', command: ['insert', '^{#?}'] },
                            { class: 'action', label: '_', command: ['insert', '_{#?}'] }, { latex: '=' }, { latex: '\\{' }, { latex: '\\}' }, { latex: '\\backslash' }
                        ],
                        [
                            { class: 'action', label: '<span style="display:block; width:100%; height:100%" onpointerdown="window.startBackspace(event)" onpointerup="window.stopBackspace()" onpointerleave="window.stopBackspace()">‚å´</span>', width: 1.5, command: 'ignore' },
                            { latex: '@' }, { latex: '\\#' },
                            { latex: '[' }, { latex: ']' },
                            { latex: ',' }, { latex: '.' }
                        ],
                        [
                            { class: 'action', label: 'ABC', width: 1.5, command: ['switchKeyboardLayer', 'mobile-default'] },
                            { latex: '<' },
                            { class: 'action', label: 'Undo', width: 1.0, command: 'undo' },
                            { class: 'action', label: ' ', latex: '\\,', width: 4 },
                            { latex: '>' },
                            { class: 'action', label: '‚Üµ', latex: '\\\\', width: 1.5, style: 'background: #4da6ff; color: white; border-color: #4da6ff;' }
                        ]
                    ]
                }
            ];
            // Ensure proper startup
            window.mathVirtualKeyboard.alphabeticLayout = 'qwerty';
            window.mathVirtualKeyboard.devicePixelRatio = 2; // sharper on mobile
        }


        // Pre-sort keys by length descending for correct matching order
        const sortedShortcutKeys = Object.keys(savedShortcuts).sort((a, b) => b.length - a.length);
        // Identify keys that are prefixes of others (e.g. 'in' is prefix of 'int') to delay their execution
        const ambiguousKeys = new Set(sortedShortcutKeys.filter(k => sortedShortcutKeys.some(other => other !== k && other.startsWith(k))));
        let shortcutTimer = null;

        function showToast(msg) { toastEl.textContent = msg; toastEl.style.display = 'block'; setTimeout(() => { toastEl.style.display = 'none'; }, 3000); }

        /* --- TOOLBAR UI --- */
        ['pointer', 'pen', 'line', 'circle', 'curve', 'eraser', 'arrow'].forEach(t => {
            const el = document.getElementById('tool-' + t);
            if (el) el.onclick = () => {
                currentTool = t;
                curveStep = 0;
                document.querySelectorAll('.side-btn').forEach(b => b.classList.remove('active'));
                el.classList.add('active');
                // Arrow tool uses canvas area, other tools use drawSurface
                drawSurface.classList.toggle('active', t !== 'pointer' && t !== 'arrow');
            };
        });

        document.getElementById('tool-grid').onclick = () => {
            const g = document.getElementById('grid-layer');
            const h = g.style.display === 'none';
            g.style.display = h ? 'block' : 'none';
            document.getElementById('tool-grid').classList.toggle('active', h);
        };

        /* --- HISTORY ENGINE (Memory-Limited) --- */
        function saveHistory(type, obj) {
            historyStack.push({ type, obj, state: drawingLayer.toDataURL() });
            // Prevent memory leaks: limit history stack size
            if (historyStack.length > MAX_HISTORY_SIZE) {
                historyStack.shift(); // Remove oldest entry
            }
            triggerAutoSave();
        }

        /* --- AUTO-SAVE SYSTEM --- */
        function triggerAutoSave() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveToLocalStorage, AUTOSAVE_DELAY);
        }

        function saveToLocalStorage() {
            try {
                const data = {
                    format: 'ABLE_AUTOSAVE',
                    version: 1,
                    timestamp: Date.now(),
                    boxes: Array.from(document.querySelectorAll('.math-box')).map(b => ({
                        x: b.offsetLeft,
                        y: b.offsetTop,
                        c: b.querySelector('math-field').value
                    })),
                    arrows: Array.from(arrowLayer.querySelectorAll('line')).map(l => ({
                        x1: l.getAttribute('x1'),
                        y1: l.getAttribute('y1'),
                        x2: l.getAttribute('x2'),
                        y2: l.getAttribute('y2')
                    })),
                    draw: drawingLayer.toDataURL()
                };
                localStorage.setItem('able_autosave', JSON.stringify(data));
                console.log('Auto-saved at', new Date().toLocaleTimeString());
            } catch (e) {
                console.warn('Auto-save failed:', e);
            }
        }

        function loadFromLocalStorage() {
            try {
                const saved = localStorage.getItem('able_autosave');
                if (!saved) return false;

                const d = JSON.parse(saved);
                if (d.format !== 'ABLE_AUTOSAVE') return false;

                // Clear existing content
                document.querySelectorAll('.math-box').forEach(b => b.remove());
                arrowLayer.querySelectorAll('line').forEach(l => l.remove());

                // Restore boxes
                if (d.boxes && d.boxes.length > 0) {
                    d.boxes.forEach(bx => createMathBox(bx.x, bx.y, bx.c));
                }

                // Restore arrows
                if (d.arrows) {
                    d.arrows.forEach(ar => {
                        const l = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        l.setAttribute('x1', ar.x1);
                        l.setAttribute('y1', ar.y1);
                        l.setAttribute('x2', ar.x2);
                        l.setAttribute('y2', ar.y2);
                        l.setAttribute('stroke', '#4da6ff');
                        l.setAttribute('stroke-width', '2');
                        l.setAttribute('marker-end', 'url(#arrowhead)');
                        arrowLayer.appendChild(l);
                    });
                }

                // Restore drawing
                if (d.draw) {
                    const img = new Image();
                    img.onload = () => {
                        dCtx.clearRect(0, 0, drawingLayer.width, drawingLayer.height);
                        dCtx.drawImage(img, 0, 0);
                    };
                    img.src = d.draw;
                }

                console.log('Restored from auto-save:', new Date(d.timestamp).toLocaleString());
                showToast('Session restored from auto-save');
                return d.boxes && d.boxes.length > 0;
            } catch (e) {
                console.warn('Failed to load auto-save:', e);
                return false;
            }
        }

        /* --- PROPER PDF EXPORT --- */
        async function exportToPDF() {
            showToast('Generating PDF...');

            try {
                // Temporarily hide UI elements
                const uiElements = document.querySelectorAll('.sidebar, #mode-status, #help-btn, .controls, #brand-header, #toast, #mobile-menu-btn');
                uiElements.forEach(el => el.style.visibility = 'hidden');

                // Color Inversion for Document Mode (Dark UI -> White PDF)
                let originalFilter = '';
                if (editorMode === 'document') {
                    originalFilter = document.body.style.filter;
                    document.body.style.filter = 'invert(1) hue-rotate(180deg)';
                    // hue-rotate ensures blue ink stays blue (otherwise it turns orange)
                }

                // Calculate content bounds
                let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;

                if (editorMode === 'document') {
                    // In document mode, capture the whole "Page"
                    minX = 0; minY = 0;
                    maxX = 1200; maxY = 1600;
                    // Or specific canvas size
                    maxX = drawingLayer.width;
                    maxY = drawingLayer.height;
                } else {
                    document.querySelectorAll('.math-box').forEach(box => {
                        const rect = box.getBoundingClientRect();
                        minX = Math.min(minX, rect.left + window.scrollX);
                        minY = Math.min(minY, rect.top + window.scrollY);
                        maxX = Math.max(maxX, rect.right + window.scrollX);
                        maxY = Math.max(maxY, rect.bottom + window.scrollY);
                    });
                    // Add padding
                    const padding = 50;
                    minX = Math.max(0, minX - padding);
                    minY = Math.max(0, minY - padding);
                    maxX += padding;
                    maxY += padding;
                }

                const contentWidth = maxX - minX;
                const contentHeight = maxY - minY;

                // Capture the content area
                const canvas = await html2canvas(document.body, {
                    x: minX,
                    y: minY,
                    width: contentWidth,
                    height: contentHeight,
                    backgroundColor: editorMode === 'document' ? '#eeeeee' : '#1e1e1e', // White-ish background for doc mode (which gets inverted to dark? Wait. Logic check below)
                    // Logic Check:
                    // We want FINAL PDF to be White Paper, Black Text.
                    // Currently UI is: Dark Paper, White Text.
                    // If we Invert Body: Paper becomes White, Text becomes Black.
                    // So we capture THAT.
                    // BackgroundColor in html2canvas is applied BEHIND the capture.
                    // If body is inverted, the "bg" of body is White.
                    // So we should probably let html2canvas capture the transparent bg or use white.

                    scale: 2, // Higher quality
                    useCORS: true,
                    logging: false
                });

                // Restore UI & Colors
                if (editorMode === 'document') {
                    document.body.style.filter = originalFilter;
                }
                uiElements.forEach(el => el.style.visibility = '');

                // Create PDF
                const { jsPDF } = window.jspdf;
                const imgData = canvas.toDataURL('image/png');

                // Determine orientation
                const orientation = contentWidth > contentHeight ? 'landscape' : 'portrait';
                const pdf = new jsPDF({
                    orientation: orientation,
                    unit: 'px',
                    format: [contentWidth, contentHeight]
                });

                pdf.addImage(imgData, 'PNG', 0, 0, contentWidth, contentHeight);
                pdf.save(`ABLE_Note_${Date.now()}.pdf`);

                showToast('PDF exported successfully!');
            } catch (e) {
                console.error('PDF export failed:', e);
                showToast('PDF export failed. Try again.');
                // Restore UI in case of error
                document.querySelectorAll('.sidebar, #mode-status, #help-btn, .controls, #brand-header')
                    .forEach(el => el.style.visibility = '');
            }
        }

        /* --- CLEAR EDITOR --- */
        function clearEditor() {
            if (!confirm('Clear all content and start fresh? This cannot be undone.')) return;

            // Clear localStorage
            localStorage.removeItem('able_autosave');

            // Clear all math boxes
            document.querySelectorAll('.math-box').forEach(b => b.remove());

            // Clear all arrows
            arrowLayer.querySelectorAll('line').forEach(l => l.remove());

            // Clear drawing canvas
            dCtx.clearRect(0, 0, drawingLayer.width, drawingLayer.height);

            // Clear history
            historyStack = [];

            // Create fresh starting box
            createMathBox(window.innerWidth / 2, window.innerHeight / 2);

            showToast('Editor cleared!');
        }

        function performUndo() {
            if (historyStack.length === 0) return;
            const action = historyStack.pop();
            if (action.type === 'arrow' && action.obj) action.obj.remove();
            const prev = historyStack.length > 0 ? historyStack[historyStack.length - 1].state : null;
            if (prev) {
                const img = new Image();
                img.onload = () => { dCtx.clearRect(0, 0, drawingLayer.width, drawingLayer.height); dCtx.drawImage(img, 0, 0); };
                img.src = prev;
            } else { dCtx.clearRect(0, 0, drawingLayer.width, drawingLayer.height); }
        }

        /* --- CANVAS MANAGEMENT --- */
        const CANVAS_WIDTH = 1588; // 2 * A4 Width
        const CANVAS_HEIGHT = 3369; // 3 * A4 Height

        let editorMode = 'fixed'; // 'infinite' or 'document' -> Now effectively fixed

        // Re-implementing Toggle Document Mode for the UI Button
        const toggleDocumentMode = () => {
            // Deprecated functionality - No-op or Mode Switch if needed.
            // Keeping function signature to avoid breaking listener if bound.
            console.log("Document mode toggle deprecated.");
        };

        // Expose to window for global access if needed
        window.toggleDocumentMode = toggleDocumentMode;

        function resizeCanvas() {
            // FIXED Canvas logic (2x3 A4)
            const newWidth = CANVAS_WIDTH;
            const newHeight = CANVAS_HEIGHT;

            // Access current dimensions
            const currentW = drawingLayer.width;
            const currentH = drawingLayer.height;

            if (dataPreserved && currentW === newWidth && currentH === newHeight) return;

            // Preserve data
            let data = null;
            if (currentW > 0) {
                try { data = drawingLayer.toDataURL(); } catch (e) { }
            }

            drawingLayer.width = previewLayer.width = newWidth;
            drawingLayer.height = previewLayer.height = newHeight;

            // Apply dimensions to all interaction layers
            canvasArea.style.width = newWidth + 'px';
            canvasArea.style.height = newHeight + 'px';
            drawSurface.style.width = newWidth + 'px';
            drawSurface.style.height = newHeight + 'px';
            arrowLayer.style.width = newWidth + 'px';
            arrowLayer.style.height = newHeight + 'px';

            // Add visual border for paper boundary
            canvasArea.style.boxShadow = "0 0 50px rgba(0,0,0,0.5)";
            canvasArea.style.border = "2px dashed #555"; // Visible Boundary
            canvasArea.style.backgroundColor = "#1e1e1e"; // Match theme, or make it distinct? Keeping dark.

            [dCtx, pCtx].forEach(c => {
                c.lineCap = 'round'; c.lineJoin = 'round';
                c.strokeStyle = '#4da6ff'; c.lineWidth = 3;
            });

            if (data) {
                const img = new Image();
                img.onload = () => dCtx.drawImage(img, 0, 0);
                img.src = data;
            }
            dataPreserved = true;
        }
        let dataPreserved = false;





        /* --- UNIFIED MOUSE INTERACTION --- */
        drawSurface.addEventListener('mousedown', (e) => {
            if (currentTool === 'pointer') return;
            isDrawing = true;
            // Removed is-zooming optimization to fix lag
            startX = e.pageX; startY = e.pageY;
            if (currentTool === 'pen' || currentTool === 'eraser') {
                dCtx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
                dCtx.lineWidth = currentTool === 'eraser' ? 30 : 3;
                dCtx.beginPath(); dCtx.moveTo(startX, startY);
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (isDrawingArrow && activeLine) {
                activeLine.setAttribute('x2', e.pageX);
                activeLine.setAttribute('y2', e.pageY);
                return;
            }
            if (!isDrawing) return;
            const curX = e.pageX, curY = e.pageY;

            if (currentTool === 'pen' || currentTool === 'eraser') {
                dCtx.lineTo(curX, curY); dCtx.stroke();

                // ERASER LOGIC FOR ARROWS (SVG)
                if (currentTool === 'eraser') {
                    const eraserRadius = 15;
                    const arrows = arrowLayer.querySelectorAll('line');
                    arrows.forEach(line => {
                        const x1 = parseFloat(line.getAttribute('x1')), y1 = parseFloat(line.getAttribute('y1'));
                        const x2 = parseFloat(line.getAttribute('x2')), y2 = parseFloat(line.getAttribute('y2'));
                        const A = curX - x1, B = curY - y1, C = x2 - x1, D = y2 - y1;
                        const dot = A * C + B * D, len_sq = C * C + D * D;
                        let param = -1;
                        if (len_sq !== 0) param = dot / len_sq;
                        let xx, yy;
                        if (param < 0) { xx = x1; yy = y1; }
                        else if (param > 1) { xx = x2; yy = y2; }
                        else { xx = x1 + param * C; yy = y1 + param * D; }
                        const dx = curX - xx, dy = curY - yy;
                        if (Math.sqrt(dx * dx + dy * dy) < eraserRadius) line.remove();
                    });
                }
            } else if (currentTool === 'line') {
                pCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                pCtx.beginPath(); pCtx.moveTo(startX, startY); pCtx.lineTo(curX, curY); pCtx.stroke();
            } else if (currentTool === 'circle') {
                pCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                const rx = Math.abs(curX - startX) / 2, ry = Math.abs(curY - startY) / 2;
                pCtx.beginPath(); pCtx.ellipse(startX + (curX - startX) / 2, startY + (curY - startY) / 2, rx, ry, 0, 0, 2 * Math.PI); pCtx.stroke();
            } else if (currentTool === 'curve') {
                pCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                if (curveStep === 0) { pCtx.beginPath(); pCtx.moveTo(startX, startY); pCtx.lineTo(curX, curY); pCtx.stroke(); }
                else { pCtx.beginPath(); pCtx.moveTo(curveStartX, curveStartY); pCtx.quadraticCurveTo(curX, curY, curveEndX, curveEndY); pCtx.stroke(); }
            }
        });

        window.addEventListener('mouseup', (e) => {
            // Optimization removed
            if (isDrawingArrow) {
                isDrawingArrow = false;
                // Double history entry removed (saved on mousedown/touchstart)
                activeLine = null;
                return;
            }
            if (!isDrawing) return;
            const curX = e.pageX, curY = e.pageY;
            if (currentTool === 'line') {
                dCtx.beginPath(); dCtx.moveTo(startX, startY); dCtx.lineTo(curX, curY); dCtx.stroke();
                saveHistory('scribble', null);
            } else if (currentTool === 'circle') {
                const rx = Math.abs(curX - startX) / 2, ry = Math.abs(curY - startY) / 2;
                dCtx.beginPath(); dCtx.ellipse(startX + (curX - startX) / 2, startY + (curY - startY) / 2, rx, ry, 0, 0, 2 * Math.PI); dCtx.stroke();
                saveHistory('scribble', null);
            } else if (currentTool === 'curve') {
                if (curveStep === 0) { curveStartX = startX; curveStartY = startY; curveEndX = curX; curveEndY = curY; curveStep = 1; }
                else { dCtx.beginPath(); dCtx.moveTo(curveStartX, curveStartY); dCtx.quadraticCurveTo(curX, curY, curveEndX, curveEndY); dCtx.stroke(); saveHistory('scribble', null); curveStep = 0; }
            } else if (currentTool === 'pen' || currentTool === 'eraser') { saveHistory('scribble', null); }
            pCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
            isDrawing = false;
        });

        /* --- ARROW ENGINE (SHIFT + DRAG or Arrow Tool) --- */
        window.addEventListener('mousedown', (e) => {
            if (e.shiftKey || currentTool === 'arrow') {
                if (e.target.closest('.math-box') || e.target.closest('.sidebar') || e.target.closest('.controls')) return;
                isDrawingArrow = true;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', e.pageX); line.setAttribute('y1', e.pageY);
                line.setAttribute('x2', e.pageX); line.setAttribute('y2', e.pageY);
                line.setAttribute('stroke', '#4da6ff'); line.setAttribute('stroke-width', '2');
                line.setAttribute('marker-end', 'url(#arrowhead)');
                arrowLayer.appendChild(line);
                activeLine = line;
                saveHistory('arrow', line);
                e.preventDefault();
            }
        });

        /* === TOUCH SUPPORT FOR MOBILE === */

        // Helper to get touch coordinates (Corrected for Zoom & Pan)
        function getTouchPos(e) {
            const touch = e.touches[0] || e.changedTouches[0];
            // Inverse transform: (Screen - Pan) / Zoom
            return {
                x: (touch.pageX - panX) / currentZoom,
                y: (touch.pageY - panY) / currentZoom
            };
        }

        // Touch handlers for drawing surface
        drawSurface.addEventListener('touchstart', (e) => {
            if (currentTool === 'pointer' || currentTool === 'arrow') return;
            e.preventDefault();
            // Optimization removed
            const pos = getTouchPos(e);
            isDrawing = true;
            startX = pos.x; startY = pos.y;
            if (currentTool === 'pen' || currentTool === 'eraser') {
                dCtx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';
                dCtx.lineWidth = currentTool === 'eraser' ? 50 : 3; // Wider eraser for mobile
                dCtx.beginPath(); dCtx.moveTo(startX, startY);
            }
        }, { passive: false });

        let drawRafId = null;
        drawSurface.addEventListener('touchmove', (e) => {
            if (!isDrawing) return;
            e.preventDefault();

            // Store event data for the RAF loop
            const pos = getTouchPos(e);
            const curX = pos.x;
            const curY = pos.y;

            if (!drawRafId) {
                drawRafId = requestAnimationFrame(() => {
                    if (currentTool === 'pen' || currentTool === 'eraser') {
                        dCtx.lineTo(curX, curY); dCtx.stroke();

                        // MOBILE ERASER LOGIC FOR ARROWS
                        if (currentTool === 'eraser') {
                            const eraserRadius = 25; // Larger radius for finger
                            const arrows = arrowLayer.querySelectorAll('line');
                            arrows.forEach(line => {
                                const x1 = parseFloat(line.getAttribute('x1')), y1 = parseFloat(line.getAttribute('y1'));
                                const x2 = parseFloat(line.getAttribute('x2')), y2 = parseFloat(line.getAttribute('y2'));
                                const A = curX - x1, B = curY - y1, C = x2 - x1, D = y2 - y1;
                                const dot = A * C + B * D, len_sq = C * C + D * D;
                                let param = -1;
                                if (len_sq !== 0) param = dot / len_sq;
                                let xx, yy;
                                if (param < 0) { xx = x1; yy = y1; }
                                else if (param > 1) { xx = x2; yy = y2; }
                                else { xx = x1 + param * C; yy = y1 + param * D; }
                                const dx = curX - xx, dy = curY - yy;
                                if (Math.sqrt(dx * dx + dy * dy) < eraserRadius) line.remove();
                            });
                        }
                    } else if (currentTool === 'line') {
                        pCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                        pCtx.beginPath(); pCtx.moveTo(startX, startY); pCtx.lineTo(curX, curY); pCtx.stroke();
                    } else if (currentTool === 'circle') {
                        pCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                        const rx = Math.abs(curX - startX) / 2, ry = Math.abs(curY - startY) / 2;
                        pCtx.beginPath(); pCtx.ellipse(startX + (curX - startX) / 2, startY + (curY - startY) / 2, rx, ry, 0, 0, 2 * Math.PI); pCtx.stroke();
                    } else if (currentTool === 'curve') {
                        pCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
                        if (curveStep === 0) { pCtx.beginPath(); pCtx.moveTo(startX, startY); pCtx.lineTo(curX, curY); pCtx.stroke(); }
                        else { pCtx.beginPath(); pCtx.moveTo(curveStartX, curveStartY); pCtx.quadraticCurveTo(curX, curY, curveEndX, curveEndY); pCtx.stroke(); }
                    }
                    drawRafId = null;
                });
            }
        }, { passive: false });

        drawSurface.addEventListener('touchend', (e) => {
            // Optimization removed
            if (!isDrawing) return;

            const pos = getTouchPos(e);
            const curX = pos.x, curY = pos.y;
            if (currentTool === 'line') {
                dCtx.beginPath(); dCtx.moveTo(startX, startY); dCtx.lineTo(curX, curY); dCtx.stroke();
                saveHistory('scribble', null);
            } else if (currentTool === 'circle') {
                const rx = Math.abs(curX - startX) / 2, ry = Math.abs(curY - startY) / 2;
                dCtx.beginPath(); dCtx.ellipse(startX + (curX - startX) / 2, startY + (curY - startY) / 2, rx, ry, 0, 0, 2 * Math.PI); dCtx.stroke();
                saveHistory('scribble', null);
            } else if (currentTool === 'curve') {
                if (curveStep === 0) { curveStartX = startX; curveStartY = startY; curveEndX = curX; curveEndY = curY; curveStep = 1; }
                else { dCtx.beginPath(); dCtx.moveTo(curveStartX, curveStartY); dCtx.quadraticCurveTo(curX, curY, curveEndX, curveEndY); dCtx.stroke(); saveHistory('scribble', null); curveStep = 0; }
            } else if (currentTool === 'pen' || currentTool === 'eraser') { saveHistory('scribble', null); }
            pCtx.clearRect(0, 0, previewLayer.width, previewLayer.height);
            isDrawing = false;
        });

        // Touch handlers for arrow tool
        canvasArea.addEventListener('touchstart', (e) => {
            if (currentTool !== 'arrow') return;
            if (e.target.closest('.math-box') || e.target.closest('.sidebar') || e.target.closest('.controls')) return;
            e.preventDefault();
            const pos = getTouchPos(e);
            isDrawingArrow = true;
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', pos.x); line.setAttribute('y1', pos.y);
            line.setAttribute('x2', pos.x); line.setAttribute('y2', pos.y);
            line.setAttribute('stroke', '#4da6ff'); line.setAttribute('stroke-width', '2');
            line.setAttribute('marker-end', 'url(#arrowhead)');
            arrowLayer.appendChild(line);
            activeLine = line;
            saveHistory('arrow', line);
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (isDrawingArrow && activeLine) {
                const pos = getTouchPos(e);
                activeLine.setAttribute('x2', pos.x);
                activeLine.setAttribute('y2', pos.y);
            }
        }, { passive: true });

        window.addEventListener('touchend', () => {
            if (isDrawingArrow) { isDrawingArrow = false; activeLine = null; }
        });

        // Note: Double-tap removed (too sensitive on mobile). Use "New Math Box" button in drawer instead.

        /* --- DYNAMIC STRUCTURES --- */
        function generateStructure(r, c, type) {
            let s = `\\begin{${type}}`;
            for (let i = 0; i < r; i++) {
                for (let j = 0; j < c; j++) { s += (i === 0 && j === 0) ? '#@' : '#?'; if (j < c - 1) s += ' & '; }
                if (i < r - 1) s += ' \\\\ ';
            }
            return s + `\\end{${type}}`;
        }

        function createMathBox(x, y, initialValue = "") {
            const container = document.createElement('div');
            container.className = 'math-box';

            // Safe Spawn: Clamp initial position to be strictly inside canvas with padding
            // Assuming strict boundaries 0 to CANVAS_WIDTH/HEIGHT
            // We don't know width yet, so we ensure at least left/top margin
            x = Math.max(20, Math.min(CANVAS_WIDTH - 100, x));
            y = Math.max(20, Math.min(CANVAS_HEIGHT - 60, y));

            container.style.left = x + 'px'; container.style.top = y + 'px';
            const handle = document.createElement('div'); handle.className = 'box-handle'; container.appendChild(handle);
            const closeBtn = document.createElement('div'); closeBtn.className = 'close-box-btn'; closeBtn.innerHTML = '&times;'; closeBtn.onclick = () => { container.remove(); updateCanvasHeight(); }; container.appendChild(closeBtn);
            const mfe = new MathfieldElement(); container.appendChild(mfe); canvasArea.appendChild(container);

            // Universal Keyboard Policy
            mfe.mathVirtualKeyboardPolicy = isMobile ? 'auto' : 'manual';
            mfe.virtualKeyboardMode = isMobile ? 'onfocus' : 'off';
            mfe.value = initialValue;

            // DISABLE standard shortcuts to prevent conflicts - WE HANDLE EVERYTHING NOW
            mfe.inlineShortcuts = {};

            // DEBUG OVERLAY
            const debugOverlay = document.createElement('div');
            debugOverlay.style.cssText = 'position:absolute; bottom:-20px; right:0; font-size:10px; color:#aaa; font-family:monospace; pointer-events:none;';
            debugOverlay.className = 'debug-buffer';
            debugOverlay.textContent = 'Buffer: []';
            container.appendChild(debugOverlay);

            mfe.addEventListener('input', () => {
                const v = mfe.value;

                // Matrix/determinant shortcuts
                const mm = v.match(/([1-9])([1-9])mat$/);
                const dm = v.match(/([1-9])([1-9])det$/);
                if (mm) { for (let i = 0; i < 5; i++) mfe.executeCommand('deleteBackward'); mfe.executeCommand(['insert', generateStructure(parseInt(mm[1]), parseInt(mm[2]), 'pmatrix')]); return; }
                if (dm) { for (let i = 0; i < 5; i++) mfe.executeCommand('deleteBackward'); mfe.executeCommand(['insert', generateStructure(parseInt(dm[1]), parseInt(dm[2]), 'vmatrix')]); return; }

                // UNIVERSAL SHORTCUT ENGINE (Robust Diff + Buffer)
                if (sortedShortcutKeys) {
                    // Cancel ambiguous match
                    if (shortcutTimer) { clearTimeout(shortcutTimer); shortcutTimer = null; }

                    // Initialize state
                    if (mfe._prevValue === undefined) mfe._prevValue = '';
                    if (!mfe._keyBuffer) mfe._keyBuffer = '';
                    if (!mfe._lastInputTime) mfe._lastInputTime = 0;

                    const prev = mfe._prevValue;

                    // 1. PERMISSIVE DIFF LOGIC (Prefix/Suffix + Noise Filtering)

                    let prefixLen = 0;
                    while (prefixLen < prev.length && prefixLen < v.length && prev[prefixLen] === v[prefixLen]) {
                        prefixLen++;
                    }

                    let suffixLen = 0;
                    while (suffixLen < (prev.length - prefixLen) && suffixLen < (v.length - prefixLen) &&
                        prev[prev.length - 1 - suffixLen] === v[v.length - 1 - suffixLen]) {
                        suffixLen++;
                    }

                    const inserted = v.slice(prefixLen, v.length - suffixLen);
                    const deleted = prev.slice(prefixLen, prev.length - suffixLen);

                    let charTyped = null;

                    // PERMISSIVE CHECK:
                    // If we inserted text, strip out braces/slashes/spaces to see if there's a SINGLE valid char.
                    if (inserted.length > 0) {
                        // Remove common noise: braces, backslashes, spaces, newlines, parens
                        const cleanInserted = inserted.replace(/[{}\s\\()]/g, '');

                        if (cleanInserted.length === 1) {
                            charTyped = cleanInserted;
                            console.log(`[Diff] Noisy insertion detected. Raw: "${inserted}" -> Clean: "${charTyped}"`);
                        } else if (cleanInserted.length === 0 && inserted.length > 0) {
                            // Just noise (e.g. formatting change). Ignore.
                            console.log(`[Diff] Ignored noise: "${inserted}"`);
                        } else {
                            // Multiple real chars (paste?) -> Reset
                            mfe._keyBuffer = '';
                        }
                    }

                    // Buffer Update
                    if (charTyped) {
                        mfe._keyBuffer += charTyped;
                    } else if (deleted.length > 0 && inserted.length === 0) {
                        // Backspace (lenient: any pure deletion is a backspace)
                        mfe._keyBuffer = mfe._keyBuffer.slice(0, -1);
                    }

                    // Update UI
                    debugOverlay.innerText = `Buf: [${mfe._keyBuffer}]`;
                    debugOverlay.style.color = mfe._keyBuffer ? '#4da6ff' : '#aaa';
                    if (mfe._keyBuffer === 'Executed') debugOverlay.style.color = '#0f0';

                    // Update tracking
                    mfe._prevValue = v;
                    mfe._lastInputTime = Date.now();

                    // 2. CHECK SHORTCUTS
                    if (isMathMode) { // Enforce Math Mode for Shortcuts
                        for (const key of sortedShortcutKeys) {
                            if (mfe._keyBuffer && mfe._keyBuffer.endsWith(key) && !mfe._keyBuffer.endsWith('\\\\' + key)) {
                                // Boundary check: Word boundary
                                const prefix = mfe._keyBuffer.slice(0, -key.length);
                                if (prefix.length > 0 && /[a-zA-Z]$/.test(prefix)) continue;

                                const executeShortcut = () => {
                                    const latex = savedShortcuts[key];
                                    for (let i = 0; i < key.length; i++) mfe.executeCommand('deleteBackward');
                                    mfe.executeCommand(['insert', latex]);
                                    mfe._keyBuffer = '';
                                    debugOverlay.innerText = 'Buf: [Executed]';
                                    debugOverlay.style.color = '#0f0';
                                };

                                if (ambiguousKeys.has(key)) {
                                    shortcutTimer = setTimeout(() => executeShortcut(), 300);
                                } else {
                                    executeShortcut();
                                }
                                return;
                            }
                        }
                    }
                }

            });

            // 3. SELECTION MONITOR
            mfe.addEventListener('selection-change', () => {
                const timeSinceInput = Date.now() - (mfe._lastInputTime || 0);
                if (timeSinceInput > 2000) {
                    mfe._keyBuffer = '';
                    if (debugOverlay) debugOverlay.innerText = 'Buf: []';
                }
            });

            setupDrag(handle, container); attachKeyHandlers(mfe);
            mfe.onfocus = () => { container.classList.add('focused'); };
            mfe.onblur = () => container.classList.remove('focused');
            setTimeout(() => { if (!initialValue) mfe.focus(); updateCanvasHeight(); triggerAutoSave(); }, 50);
        }


        function setupDrag(handle, container) {
            let drg = false; let sx, sy, il, it;

            // Mouse drag (desktop)
            handle.onmousedown = (e) => {
                if (e.shiftKey || currentTool !== 'pointer') return;
                drg = true; sx = e.pageX; sy = e.pageY;
                il = container.offsetLeft; it = container.offsetTop;
                e.preventDefault(); e.stopPropagation();
            };
            window.addEventListener('mousemove', (e) => {
                if (!drg) return;
                let newX = il + (e.pageX - sx);
                let newY = it + (e.pageY - sy);

                // Clamp to canvas boundaries
                const maxX = CANVAS_WIDTH - container.offsetWidth;
                const maxY = CANVAS_HEIGHT - container.offsetHeight;

                newX = Math.max(0, Math.min(maxX, newX));
                newY = Math.max(0, Math.min(maxY, newY));

                container.style.left = newX + 'px';
                container.style.top = newY + 'px';
            });
            window.addEventListener('mouseup', () => { if (drg) { drg = false; triggerAutoSave(); } });

            // Touch drag for mobile - use long press on container to initiate drag
            let longPressTimer = null;
            let isDragging = false;

            container.addEventListener('touchstart', (e) => {
                if (currentTool !== 'pointer') return;
                // Only start drag if not touching the math-field directly (allow focus) OR the close button
                if (e.target.tagName === 'MATH-FIELD' || e.target.closest('math-field') || e.target.closest('.close-box-btn')) {
                    // User tapped math field or close button - let default actions happen
                    return;
                }

                e.preventDefault();
                const touch = e.touches[0];
                sx = touch.pageX; sy = touch.pageY;
                il = container.offsetLeft; it = container.offsetTop;
                isDragging = true;
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const touch = e.touches[0];
                let newX = il + (touch.pageX - sx);
                let newY = it + (touch.pageY - sy);

                // Clamp to canvas boundaries
                const maxX = CANVAS_WIDTH - container.offsetWidth;
                const maxY = CANVAS_HEIGHT - container.offsetHeight;

                newX = Math.max(0, Math.min(maxX, newX));
                newY = Math.max(0, Math.min(maxY, newY));

                container.style.left = newX + 'px';
                container.style.top = newY + 'px';
            }, { passive: false });

            container.addEventListener('touchend', () => {
                if (isDragging) {
                    isDragging = false;
                    triggerAutoSave();
                    updateCanvasHeight();
                }
            });
        }

        function updateCanvasHeight() {
            // DISABLED for Fixed Size
            // resizeCanvas();
        }

        function toggleHelp() { helpModal.style.display = helpModal.style.display === 'flex' ? 'none' : 'flex'; }
        function toggleMode() { isMathMode = !isMathMode; statusEl.textContent = isMathMode ? "MODE: MATH" : "MODE: TEXT"; statusEl.classList.toggle('active', isMathMode); document.querySelectorAll('math-field').forEach(f => f.inlineShortcuts = isMathMode ? savedShortcuts : {}); }

        function attachKeyHandlers(mfe) {
            mfe.addEventListener('keydown', (ev) => {
                if (ev.key === 'F1') { ev.preventDefault(); toggleHelp(); }
                if (ev.key === 'Tab' && ev.shiftKey) { ev.preventDefault(); toggleMode(); }
                if (ev.key === 'Enter') { ev.preventDefault(); mfe.executeCommand(['insert', '\\\\']); }
                // Don't intercept Space - let MathLive's inlineShortcuts process it naturally
                // (User types 'alpha' + Space -> MathLive converts to Œ± automatically)
                if (!isMathMode) return;
                if (ev.code === 'Numpad7') mfe.executeCommand(['insert', '\\int_{#@}^{#@}']);
                if (ev.code === 'Numpad8') mfe.executeCommand(['insert', '\\sum_{#@}^{#@}']);
                if (ev.code === 'Numpad9') mfe.executeCommand(['insert', '\\sqrt{#@}']);
                if (ev.code === 'Numpad4') mfe.executeCommand(['insert', '\\lim_{#@ \\to #@}']);
                if (ev.code === 'Numpad5') {
                    const now = Date.now();
                    if (now - lastMatrixTap < 800) { matrixSize++; if (matrixSize > 2) matrixSize = 0; mfe.executeCommand('moveToGroupStart'); mfe.executeCommand('moveToPreviousChar'); mfe.executeCommand('deleteForward'); }
                    else { matrixSize = 0; }
                    lastMatrixTap = now;
                    if (matrixSize === 0) mfe.executeCommand(['insert', '\\begin{pmatrix} #@ & #@ \\\\ #@ & #@ \\end{pmatrix}']);
                    else if (matrixSize === 1) mfe.executeCommand(['insert', '\\begin{pmatrix} #@ & #@ & #@ \\\\ #@ & #@ & #@ \\\\ #@ & #@ & #@ \\end{pmatrix}']);
                    else if (matrixSize === 2) { const row = "#@ & #@ & #@ & #@ \\\\ "; mfe.executeCommand(['insert', `\\begin{pmatrix} ${row}${row}${row}#@ & #@ & #@ & #@ \\end{pmatrix}`]); }
                }
            });
        }

        /* --- GLOBAL DOUBLE CLICK --- */
        /* --- GLOBAL DOUBLE CLICK --- */
        window.addEventListener('dblclick', (e) => {
            if (e.target.closest('.controls') || e.target.closest('.sidebar') || e.target.closest('#help-btn') || e.target.closest('.math-box') || e.target.closest('math-field') || e.target.closest('.ML__keyboard')) return;

            // Fix offset: Convert screen coordinates to canvas coordinates (inverse transform)
            const x = (e.pageX - panX) / currentZoom;
            const y = (e.pageY - panY) / currentZoom;

            createMathBox(x, y);
        });

        document.getElementById('clear-btn').onclick = clearEditor;
        document.getElementById('undo-btn').onclick = performUndo;
        document.getElementById('export-able-btn').onclick = () => {
            const data = { format: "ABLE", boxes: Array.from(document.querySelectorAll('.math-box')).map(b => ({ x: b.offsetLeft, y: b.offsetTop, c: b.querySelector('math-field').value })), arrows: Array.from(arrowLayer.querySelectorAll('line')).map(l => ({ x1: l.getAttribute('x1'), y1: l.getAttribute('y1'), x2: l.getAttribute('x2'), y2: l.getAttribute('y2') })), draw: drawingLayer.toDataURL() };
            const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `Note_${Date.now()}.able`; a.click();
        };
        document.getElementById('import-able-btn').onclick = () => fileInput.click();
        fileInput.onchange = (e) => {
            const r = new FileReader(); r.onload = (ev) => {
                const d = JSON.parse(ev.target.result);
                document.querySelectorAll('.math-box').forEach(b => b.remove());
                arrowLayer.querySelectorAll('line').forEach(l => l.remove());
                d.boxes.forEach(bx => createMathBox(bx.x, bx.y, bx.c));
                d.arrows.forEach(ar => { const l = document.createElementNS('http://www.w3.org/2000/svg', 'line'); l.setAttribute('x1', ar.x1); l.setAttribute('y1', ar.y1); l.setAttribute('x2', ar.x2); l.setAttribute('y2', ar.y2); l.setAttribute('stroke', '#4da6ff'); l.setAttribute('stroke-width', '2'); l.setAttribute('marker-end', 'url(#arrowhead)'); arrowLayer.appendChild(l); });
                if (d.draw) { const img = new Image(); img.onload = () => { dCtx.clearRect(0, 0, drawingLayer.width, drawingLayer.height); dCtx.drawImage(img, 0, 0); }; img.src = d.draw; }
            }; r.readAsText(e.target.files[0]);
        };
        document.getElementById('export-btn').onclick = exportToPDF;

        /* === MOBILE DRAWER REMOVED === */

        // Drawer tool buttons
        document.querySelectorAll('#mobile-drawer .drawer-btn').forEach(btn => {
            btn.onclick = () => {
                const tool = btn.dataset.tool;

                if (tool === 'grid') {
                    // Toggle grid visibility
                    const g = document.getElementById('grid-layer');
                    const isVisible = g.style.display !== 'none';
                    g.style.display = isVisible ? 'none' : 'block';
                    btn.classList.toggle('active', !isVisible);
                } else {
                    // Set active tool
                    currentTool = tool;
                    curveStep = 0;
                    document.querySelectorAll('#mobile-drawer .drawer-btn').forEach(b => {
                        if (b.dataset.tool !== 'grid') b.classList.remove('active');
                    });
                    btn.classList.add('active');
                    drawSurface.classList.toggle('active', tool !== 'pointer' && tool !== 'arrow');

                    // Also sync with desktop sidebar
                    document.querySelectorAll('.sidebar .side-btn').forEach(b => b.classList.remove('active'));
                    const desktopBtn = document.getElementById('tool-' + tool);
                    if (desktopBtn) desktopBtn.classList.add('active');
                }

                closeMobileDrawer();
            };
        });

        // Mobile action buttons
        const mobileNewBoxBtn = document.getElementById('mobile-new-box-btn');
        if (mobileNewBoxBtn) {
            mobileNewBoxBtn.onclick = () => {
                createMathBox(window.innerWidth / 2 - 90, 150);
                closeMobileDrawer();
            };
        }

        const mobileUndoBtn = document.getElementById('mobile-undo-btn');
        if (mobileUndoBtn) {
            mobileUndoBtn.onclick = () => {
                performUndo();
                closeMobileDrawer();
            };
        }

        const mobileClearBtn = document.getElementById('mobile-clear-btn');
        if (mobileClearBtn) {
            mobileClearBtn.onclick = () => {
                closeMobileDrawer();
                clearEditor();
            };
        }

        const mobileExportAbleBtn = document.getElementById('mobile-export-able-btn');
        if (mobileExportAbleBtn) {
            mobileExportAbleBtn.onclick = () => {
                document.getElementById('export-able-btn').click();
                closeMobileDrawer();
            };
        }

        const mobileImportAbleBtn = document.getElementById('mobile-import-able-btn');
        if (mobileImportAbleBtn) {
            mobileImportAbleBtn.onclick = () => {
                fileInput.click();
                closeMobileDrawer();
            };
        }

        const mobileExportPdfBtn = document.getElementById('mobile-export-pdf-btn');
        if (mobileExportPdfBtn) {
            mobileExportPdfBtn.onclick = () => {
                closeMobileDrawer();
                exportToPDF();
            };
        }

        const mobileModeBtn = document.getElementById('mobile-mode-btn');
        if (mobileModeBtn) {
            mobileModeBtn.onclick = () => {
                toggleMode();
                closeMobileDrawer();
            };
        }

        const mobileHelpBtn = document.getElementById('mobile-help-btn');
        if (mobileHelpBtn) {
            mobileHelpBtn.onclick = () => {
                closeMobileDrawer();
                toggleHelp();
            };
        }

        /* === MATH FIELD FOCUS TRACKING === */
        // Track which math field is active for Visual Viewport scrolling
        document.addEventListener('focusin', (e) => {
            if (e.target.tagName === 'MATH-FIELD') {
                activeMathField = e.target;
            }
        });

        // Use Visual Viewport API to keep math box visible when keyboard appears
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', () => {
                if (activeMathField) {
                    // Scroll the active math box into view above the keyboard
                    const mathBox = activeMathField.closest('.math-box');
                    if (mathBox) {
                        const viewportHeight = window.visualViewport.height;
                        const boxRect = mathBox.getBoundingClientRect();

                        // If box is below the visible viewport, scroll it up
                        if (boxRect.bottom > viewportHeight - 50) {
                            mathBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }
                }
            });
        }

        /* === MOBILE FAB UI LOGIC === */
        const mobileToolsBtn = document.getElementById('mobile-tools-btn');
        const mobileToolsPanel = document.getElementById('mobile-tools-panel');
        const mobileFileBtn = document.getElementById('mobile-file-btn');
        const mobileFilePalette = document.getElementById('mobile-file-palette');
        const mobileFabContainer = document.querySelector('.mobile-fab-container');
        const mobileUndoBtnStandalone = document.getElementById('mobile-undo-btn-standalone');

        // Toggle Tools Panel
        if (mobileToolsBtn) {
            mobileToolsBtn.onclick = (e) => {
                e.stopPropagation();
                // Close File Palette if open
                mobileFabContainer.classList.remove('file-open');
                mobileFileBtn.classList.remove('active');

                // Toggle Panel
                const isOpen = mobileToolsPanel.classList.contains('open');
                mobileToolsPanel.classList.toggle('open', !isOpen);
                mobileToolsBtn.classList.toggle('active', !isOpen);
            };
        }

        // Toggle File Palette
        if (mobileFileBtn) {
            mobileFileBtn.onclick = (e) => {
                e.stopPropagation();
                // Close Tools Panel if open
                mobileToolsPanel.classList.remove('open');
                mobileToolsBtn.classList.remove('active');

                // Toggle Palette
                mobileFabContainer.classList.toggle('file-open');
                mobileFileBtn.classList.toggle('active');
            };
        }

        // Close menus when clicking outside
        window.addEventListener('click', (e) => {
            if (!e.target.closest('.mobile-fab-container')) {
                if (mobileToolsPanel) mobileToolsPanel.classList.remove('open');
                if (mobileToolsBtn) mobileToolsBtn.classList.remove('active');
                if (mobileFabContainer) mobileFabContainer.classList.remove('file-open');
                if (mobileFileBtn) mobileFileBtn.classList.remove('active');
            }
        });

        // Tool Selection Logic (Mobile)
        // Tool Selection Logic (Mobile)
        document.querySelectorAll('.mobile-tool-btn').forEach(btn => {
            btn.onclick = () => {
                const tool = btn.dataset.tool;

                // Set active tool
                currentTool = tool;
                document.querySelectorAll('.mobile-tool-btn').forEach(b => {
                    b.classList.remove('active');
                });
                btn.classList.add('active');

                // Sync with sidebar (desktop)
                document.querySelectorAll('.sidebar .side-btn').forEach(b => b.classList.remove('active'));
                const desktopBtn = document.getElementById('tool-' + tool);
                if (desktopBtn) desktopBtn.classList.add('active');

                // If tool is drawing type, ensure surface is active
                drawSurface.classList.toggle('active', tool !== 'pointer' && tool !== 'arrow');

                // Close panel after selection
                mobileToolsPanel.classList.remove('open');
                mobileToolsBtn.classList.remove('active');
            };
        });

        // File Palette Actions
        const palExport = document.getElementById('pal-export-able');
        if (palExport) palExport.onclick = () => {
            document.getElementById('export-able-btn').click();
            mobileFabContainer.classList.remove('file-open'); mobileFileBtn.classList.remove('active');
        };

        const palImport = document.getElementById('pal-import-able');
        if (palImport) palImport.onclick = () => {
            document.getElementById('import-able-btn').click();
            mobileFabContainer.classList.remove('file-open'); mobileFileBtn.classList.remove('active');
        };

        const palClear = document.getElementById('pal-clear');
        if (palClear) palClear.onclick = () => {
            clearEditor();
            mobileFabContainer.classList.remove('file-open'); mobileFileBtn.classList.remove('active');
        };

        // Standalone Undo
        if (mobileUndoBtnStandalone) {
            mobileUndoBtnStandalone.onclick = () => {
                performUndo();
            };
        }

        /* === MOBILE ZOOM & PAN === */
        let currentZoom = 1;
        let panX = 0, panY = 0;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3;
        const ZOOM_STEP = 0.25;
        const zoomWrapper = document.getElementById('zoom-wrapper');

        function clampPan() {
            const scaledW = CANVAS_WIDTH * currentZoom;
            const scaledH = CANVAS_HEIGHT * currentZoom;
            const viewW = window.innerWidth;
            const viewH = window.innerHeight;

            // Horizontal Clamp
            if (scaledW > viewW) {
                // Content larger than screen: Allow panning but clamp to edges
                // panX must be <= 0 (left edge) and >= viewW - scaledW (right edge)
                panX = Math.min(0, Math.max(viewW - scaledW, panX));
            } else {
                // Content smaller than screen: Center it
                panX = (viewW - scaledW) / 2;
            }

            // Vertical Clamp
            if (scaledH > viewH) {
                panY = Math.min(0, Math.max(viewH - scaledH, panY));
            } else {
                panY = (viewH - scaledH) / 2;
            }
        }

        function applyTransform() {
            if (zoomWrapper) {
                clampPan(); // ENFORCE BOUNDARIES
                zoomWrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${currentZoom})`;
            }
        }

        function setZoom(zoom, focalX = null, focalY = null) {
            const oldZoom = currentZoom;
            currentZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));

            // Adjust pan to zoom towards focal point
            if (focalX !== null && focalY !== null) {
                const zoomRatio = currentZoom / oldZoom;
                panX = focalX - (focalX - panX) * zoomRatio;
                panY = focalY - (focalY - panY) * zoomRatio;
            }

            applyTransform();
        }

        const zoomInBtn = document.getElementById('zoom-in-btn');
        const zoomOutBtn = document.getElementById('zoom-out-btn');
        const zoomResetBtn = document.getElementById('zoom-reset-btn');

        if (zoomInBtn) zoomInBtn.onclick = () => setZoom(currentZoom + ZOOM_STEP);
        if (zoomOutBtn) zoomOutBtn.onclick = () => setZoom(currentZoom - ZOOM_STEP);
        if (zoomResetBtn) zoomResetBtn.onclick = () => {
            currentZoom = 1;
            panX = 0;
            panY = 0;
            applyTransform();
        };

        // Pinch-to-zoom and single-finger pan support
        let initialPinchDistance = null;
        let initialZoomOnPinch = 1;
        let initialPanX = 0, initialPanY = 0;
        let lastTouchMidX = 0, lastTouchMidY = 0;

        // Single finger pan state
        let singleFingerPan = false;
        let lastSingleTouchX = 0, lastSingleTouchY = 0;

        document.addEventListener('touchstart', (e) => {
            // Prevent interference with drawing tools
            if (isDrawing || isDrawingArrow || currentTool !== 'pointer') return;

            // Single finger pan on canvas area (not on math boxes or controls)
            if (e.touches.length === 1) {
                const target = e.target;
                const isCanvas = target.id === 'canvas-area' ||
                    target.id === 'drawing-layer' ||
                    target.id === 'grid-layer' ||
                    target.id === 'zoom-wrapper' ||
                    target.closest('#canvas-area') && !target.closest('.math-box') && !target.closest('math-field');

                if (isCanvas) {
                    // CRITICAL: Prevent native scroll so we can pan smoothly
                    // Only prevent if we are definitely on the canvas
                    // e.preventDefault(); // Moved to touchmove to allow clicking buttons

                    singleFingerPan = true;
                    lastSingleTouchX = e.touches[0].pageX;
                    lastSingleTouchY = e.touches[0].pageY;
                    initialPanX = panX;
                    initialPanY = panY;
                }
            }

            // Two finger pinch-zoom
            if (e.touches.length === 2) {
                e.preventDefault(); // Always prevent default on pinch

                // Performance Comp
                if (!singleFingerPan) document.body.classList.add('is-zooming');

                singleFingerPan = false; // Cancel single finger pan when second finger touches
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                initialPinchDistance = Math.sqrt(dx * dx + dy * dy);
                initialZoomOnPinch = currentZoom;
                initialPanX = panX;
                initialPanY = panY;
                lastTouchMidX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
                lastTouchMidY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
            }
        }, { passive: false });

        // Optimized touchmove with requestAnimationFrame
        let zoomRafId = null;

        document.addEventListener('touchmove', (e) => {
            // Single finger pan
            if (e.touches.length === 1 && singleFingerPan) {
                e.preventDefault(); // STOP NATIVE SCROLL

                // Performance Comp (Same as zoom)
                document.body.classList.add('is-zooming');

                const dx = e.touches[0].pageX - lastSingleTouchX;
                const dy = e.touches[0].pageY - lastSingleTouchY;
                panX = initialPanX + dx;
                panY = initialPanY + dy;
            }

            // Two finger pinch-zoom
            if (e.touches.length === 2 && initialPinchDistance) {
                e.preventDefault(); // STOP NATIVE ZOOM
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, initialZoomOnPinch * (currentDistance / initialPinchDistance)));

                // Calculate current midpoint (focal point)
                const midX = (e.touches[0].pageX + e.touches[1].pageX) / 2;
                const midY = (e.touches[0].pageY + e.touches[1].pageY) / 2;

                // Adjust pan so content under fingers stays under fingers
                const zoomRatio = newZoom / initialZoomOnPinch;
                panX = midX - (lastTouchMidX - initialPanX) * zoomRatio;
                panY = midY - (lastTouchMidY - initialPanY) * zoomRatio;

                currentZoom = newZoom;
            }

            // Schedule render update
            if (!zoomRafId && (singleFingerPan || initialPinchDistance)) {
                zoomRafId = requestAnimationFrame(() => {
                    applyTransform();
                    zoomRafId = null;
                });
            }
        }, { passive: false });

        document.addEventListener('touchend', () => {
            document.body.classList.remove('is-zooming');
            initialPinchDistance = null;
            singleFingerPan = false;
        });

        // --- MOUSE WHEEL ZOOM & PAN ---
        window.addEventListener('wheel', (e) => {
            // Only intercept if we are interacting with the canvas/wrapper
            if (e.target.closest('math-field') || e.target.closest('.sidebar') || e.target.closest('.controls') || e.target.closest('.drawer-section')) return;

            e.preventDefault();

            if (e.ctrlKey) {
                // Zoom (Ctrl + Wheel)
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, currentZoom * zoomFactor));

                // Focal point logic (Zoom towards mouse)
                // standard formula: pan = mouse - (mouse - oldPan) * (newZoom / oldZoom)
                const zoomRatio = newZoom / currentZoom;
                panX = e.clientX - (e.clientX - panX) * zoomRatio;
                panY = e.clientY - (e.clientY - panY) * zoomRatio;

                currentZoom = newZoom;
            } else {
                // Pan (Wheel / Shift+Wheel)
                panX -= e.deltaX;
                panY -= e.deltaY;
            }

            applyTransform();
        }, { passive: false });

        window.onkeydown = (e) => {
            if (e.key === 'F1') { e.preventDefault(); toggleHelp(); }
            if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) { if (document.activeElement.tagName !== 'MATH-FIELD') performUndo(); }
        };

        window.onload = () => {
            resizeCanvas();
            // Try to restore from auto-save, otherwise create default box
            const restored = loadFromLocalStorage();
            if (!restored && document.querySelectorAll('.math-box').length === 0) {
                createMathBox(window.innerWidth / 2 - 150, window.innerHeight / 2 - 60);
            }
            // Bind Mode Toggle (Input Mode: Math/Text)
            const modeBtn = document.getElementById('mode-status');
            if (modeBtn) {
                modeBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMode();
                };
                // Touch support
                modeBtn.ontouchstart = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleMode();
                };
            }

            // Bind Help Button
            const helpBtn = document.getElementById('help-btn');
            if (helpBtn) {
                helpBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleHelp();
                };
                helpBtn.ontouchstart = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    toggleHelp();
                };
            }
        };
        // Debounce resize to prevent rapid clearing on mobile UI shifts
        let resizeTimer;
        window.onresize = () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(resizeCanvas, 200);
        };
    </script>
</body>

</html>
